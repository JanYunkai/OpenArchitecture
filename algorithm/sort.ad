== 排序

|===
|排序算法|平均时间复杂度|最好情况|最坏情况|空间复杂度|排序方式|稳定性|描述

| 冒泡算法
|o(n^2)
|o(n)
|o(n^2)
|o(1)
|In-place
|稳定
| （无序区，有序区）

从无序区透过交换找出最大元素放到有序区前端

| 选择排序
|o(n^2)
|o(n^2)
|o(n^2)
|o(1)
|In-place
|不稳定
|（无序区，有序区）

在无序区里找一个最小元素跟在有序区的后面，对数组：比较得多，换得少。

|插入排序
|o(n^2)
|o(n)
|o(n^2)
|o(1)
|In-place
|稳定
|（无序区，有序区）

在无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。

|希尔排序
|o(nlog n)
|o(nlog2 n)
|o(nlog2 n)
|o(1)
|In-place
|不稳定
| 每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1.

|归并排序
|o(nlog n)
|o(nlog n)
|o(nlog n)
|o(n)
|Out-Place
|不稳定
|把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。可从上到下或从下到上进行

|快速排序
|o(nlog n)
|o(nlog n)
|o(n^2)
|o(log n)
|In-place
|不稳定
|（小数，基准元素，大数）

在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于的元素放在基准之后，再分别对小数区与大数区进行排序

|堆排序
|o(nlog n)
|o(nlog n)
|o(nlog n)
|o(1)
|In-place
|不稳定
|（最大堆，有序区）

从栈顶把根卸出来放在有序区之前，再恢复堆

|计数排序
|o(n+k)
|o(n+k)
|o(n+k)
|o(k)
|Out-Place
|稳定
| 统计小于等于该元素值的元素个数i，于是该元素就放在目标数组的索引i位（i>=0）

|桶排序
|o(n+k)
|o(n+k)
|o(n^2)
|o(n+k)
|Out-Place
|稳定
|将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。

|基数排序
|o(n*k)
|o(n*k)
|o(n*k)
|o(n+k)
|Out-Place
|稳定
|一个多关键字的排序算法，可用桶排序实现
|===

=== 冒泡算法

=== 选择排序

=== 插入排序

=== 希尔排序

=== 归并排序

=== 快速排序

=== 堆排序

=== 计数排序

=== 桶排序

=== 基数排序