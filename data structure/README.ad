== 十大常用数据结构

=== 栈

. 后缀表达式的求值
. 中缀到后缀表达式的转换
. 深度优先的非递归实现
. 动态规划的优化：用于维护一个凸序列，便于二分查找，如LIS问题的O(logn)算法。

=== 队列

. 树的层序遍历
. 广度优先搜索
. Bellman-Ford算法的SPFA实现
. 网络流中FF算法的Edmonds-Karp实现，以及Preflow算法的队列优化实现

=== 二叉搜索树

. 对大量的关键词的索引查找
. 有很多平衡策略以改善其平均性能常用平衡树：AVL，红黑树，随机化BST，Splay Tree，Treap（笛卡尔树）

=== 散列表（hash表）

. 一般针对值域较大但状态稀疏的应用比如状态压缩记忆化搜索
. 实现映射功能

=== 检索树（trie）

. 一般用于字符串索引算法，速度快，但占用空间较大（相对hash）
. 常用的改进结构：Patricia线索树，多叉索引树（TST）

=== 优先队列

. 常用的是二叉堆的实现，具体应用如堆排序和Dijkstra算法。
. 当需要快速合并两个优先队列时，常用二项式队列，实现简单
. 注意最大最小堆的配对使用

=== 线段树和树状数组

. 两者都可以用于离散对象的统计
. 后者的步进函数的性质和应用值得注意
. 前者基本适用于任何的区间操作，如求区间最值，改变区间的值等。
. 线段树还可以用于优化状态的枚举，经常和动态规划结合。

=== 后缀树与后缀数组

. 总体规律是两者实现都比较复杂，前者更甚，但是前者的功能也更强大。
. 几乎可以解决所有常见的关于字符串的算法，如最长回文子串，最长重复子串，以及很多模式匹配问题。

=== 并查集

. 解决无向图的连接性问题如用于Kruskal算法
. 解决等价关系的查询（这是它主要的用武之地），如05年Baidu之星初赛的石头剪子布游戏；
. 优点是实现异常简单，缺点是合并后无法分离，若需要可选择用动态树

=== 临接表与边表

. 表示图的最直接方法
. 后者更省空间，并且在一定程度上更好用，比如Bellman-Ford算法
ps 数组、链表太基础不在考量之列